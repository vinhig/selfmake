// LICENSE NOTICE ==================================================================================

/**
 * netzhaut - Web Browser Engine
 * Copyright (C) 2020 The netzhaut Authors
 * Published under LGPLv3
 */

// INCLUDE =========================================================================================

#include "WebIDL.h"
#include "Util.h"

#include "../Common/Macro.h"
#include SELFMAKE_FLOW
#include SELFMAKE_DEFAULT_CHECK

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>

// DECLARE =========================================================================================

#define LICENSE_NOTICE \
    "/**\n * netzhaut - Web Browser Engine\n * Copyright (C) 2020 The netzhaut Authors\n * Published under LGPLv3\n *\n * This file was generated by nhmake\n */\n\n"

static NH_BYTE *files_pp[] = {
    "src/lib/nhwebidl/Specifications/DOM/TreeWalker.idl",
    "src/lib/nhwebidl/Specifications/DOM/Text.idl",
    "src/lib/nhwebidl/Specifications/DOM/StaticRange.idl",
    "src/lib/nhwebidl/Specifications/DOM/Slottable.idl",
    "src/lib/nhwebidl/Specifications/DOM/ShadowRoot.idl",
    "src/lib/nhwebidl/Specifications/DOM/Range.idl",
    "src/lib/nhwebidl/Specifications/DOM/ProcessingInstruction.idl",
    "src/lib/nhwebidl/Specifications/DOM/ParentNode.idl",
    "src/lib/nhwebidl/Specifications/DOM/NonElementParentNode.idl",
    "src/lib/nhwebidl/Specifications/DOM/NonDocumentTypeChildNode.idl",
    "src/lib/nhwebidl/Specifications/DOM/NodeList.idl",
    "src/lib/nhwebidl/Specifications/DOM/NodeIterator.idl",
    "src/lib/nhwebidl/Specifications/DOM/NodeFilter.idl",
    "src/lib/nhwebidl/Specifications/DOM/Node.idl",
    "src/lib/nhwebidl/Specifications/DOM/NamedNodeMap.idl",
    "src/lib/nhwebidl/Specifications/DOM/MutationRecord.idl",
    "src/lib/nhwebidl/Specifications/DOM/MutationObserver.idl",
    "src/lib/nhwebidl/Specifications/DOM/HTMLCollection.idl",
    "src/lib/nhwebidl/Specifications/DOM/EventTarget.idl",
    "src/lib/nhwebidl/Specifications/DOM/Event.idl",
    "src/lib/nhwebidl/Specifications/DOM/Element.idl",
    "src/lib/nhwebidl/Specifications/DOM/DocumentType.idl",
    "src/lib/nhwebidl/Specifications/DOM/DocumentOrShadowRoot.idl",
    "src/lib/nhwebidl/Specifications/DOM/DocumentFragment.idl",
    "src/lib/nhwebidl/Specifications/DOM/Document.idl",
    "src/lib/nhwebidl/Specifications/DOM/DOMTokenList.idl",
    "src/lib/nhwebidl/Specifications/DOM/DOMImplementation.idl",
    "src/lib/nhwebidl/Specifications/DOM/Comment.idl",
    "src/lib/nhwebidl/Specifications/DOM/ChildNode.idl",
    "src/lib/nhwebidl/Specifications/DOM/CharacterData.idl",
    "src/lib/nhwebidl/Specifications/DOM/CDataSection.idl",
    "src/lib/nhwebidl/Specifications/DOM/Attr.idl",
    "src/lib/nhwebidl/Specifications/DOM/AbstractRange.idl",
    "src/lib/nhwebidl/Specifications/DOM/AbortSignal.idl",
    "src/lib/nhwebidl/Specifications/DOM/AbortController.idl",
    "src/lib/nhwebidl/Specifications/HTML/AbstractWorker.idl",
    "src/lib/nhwebidl/Specifications/HTML/AudioAndVideoTrackList.idl",
    "src/lib/nhwebidl/Specifications/HTML/CanvasRenderingContext2D.idl",
    "src/lib/nhwebidl/Specifications/HTML/CustomElementRegistry.idl",
    "src/lib/nhwebidl/Specifications/HTML/DOMStringMap.idl",
    "src/lib/nhwebidl/Specifications/HTML/DedicatedWorkerGlobalScope.idl",
    "src/lib/nhwebidl/Specifications/HTML/Document.idl",
    "src/lib/nhwebidl/Specifications/HTML/DocumentOrShadowRoot.idl",
    "src/lib/nhwebidl/Specifications/HTML/ElementInternals.idl",
    "src/lib/nhwebidl/Specifications/HTML/FormDataEvent.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLAnchorElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLAreaElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLAudioElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLBRElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLBaseElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLBodyElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLButtonElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLCanvasElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLDListElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLDataElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLDataListElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLDetailsElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLDialogElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLDivElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLEmbedElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLFieldSetElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLFormElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLHRElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLHeadElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLHeadingElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLHtmlElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLHyperlinkElementUtils.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLIFrameElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLImageElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLInputElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLLIElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLLabelElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLLegendElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLLinkElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLMapElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLMediaElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLMediaError.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLMenuElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLMetaElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLMeterElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLModElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLOListElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLObjectElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLOptGroupElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLOptionElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLOrSVGElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLOutputElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLParagraphElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLParamElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLPictureElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLPreElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLProgressElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLQuoteElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLScriptElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLSelectElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLSlotElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLSourceElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLSpanElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLStyleElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLTableCellElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLTableColElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLTableElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLTableRowElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLTableSectionElement.idl",
    "src/lib/nhwebidl/Specifications/HTML/HTMLTitleElement.idl",
};

static int fileCount = sizeof(files_pp)/sizeof(files_pp[0]);
static NH_BYTE *totalOperations_pp[16384] = {'\0'}; // should suffice
static int totalOperationCount = 0;

// HELPER ==========================================================================================

static SELFMAKE_RESULT selfmake_getFragmentName(
    NH_BYTE *filepath_p, NH_BYTE *fragmentname_p)
{
SELFMAKE_BEGIN()

    filepath_p = filepath_p + strlen(filepath_p);
    while (*filepath_p != '/') {filepath_p = filepath_p - 1;}
    filepath_p = filepath_p - 1;
    while (*filepath_p != '/') {filepath_p = filepath_p - 1;}
    filepath_p = filepath_p + 1;
    for (int i = 0; strcmp(filepath_p, ".idl"); ++i) {fragmentname_p[i] = *filepath_p; filepath_p = filepath_p + 1;}
    for (int i = 0; i < strlen(fragmentname_p); ++i) {if (fragmentname_p[i] == '/') {fragmentname_p[i] = '_';}}

SELFMAKE_END(SELFMAKE_SUCCESS)
}

//static NH_BOOL selfmake_hasExtendedAttribute(
//    nh_Array ExtendedAttributes, SELFMAKE_EXTENDED_ATTRIBUTE type)
//{
//SELFMAKE_BEGIN()
//
//    for (int i = 0; i < ExtendedAttributes.length; ++i) {
//        selfmake_ExtendedAttribute *ExtendedAttribute_p = 
//            &((selfmake_ExtendedAttribute*)ExtendedAttributes.bytes_p)[i];
//        if (ExtendedAttribute_p->type == type) {
//            SELFMAKE_END(NH_TRUE)
//        }
//    }
//
//SELFMAKE_END(NH_FALSE)
//}
//
//// FRAGMENT DATA HEADER ============================================================================
//
//static int fileCount = 0;
//static NH_BYTE *files_pp[2048] = {NULL};
//
//static int serializationDataCount = 0;
//static selfmake_SerializationData SerializationData_p[2048];
//
//static NH_BOOL selfmake_functionImplemented(
//    NH_BYTE *runtimePath_p, NH_BYTE *fragmentName_p, NH_BYTE *operationName_p)
//{
//SELFMAKE_BEGIN()
//
//    NH_BYTE str_p[1024] = {'\0'};
//    strcpy(str_p, runtimePath_p);
//    for (int i = strlen(str_p) - 1; str_p[i] != '/'; --i) {str_p[i] = '\0';}
//
//    NH_BYTE tmp_p[1024] = {'\0'};
//    strcpy(tmp_p, fragmentName_p);
//    for (int i = 0; i < strlen(tmp_p); ++i) {if (tmp_p[i] == '_') {tmp_p[i] = '/';}}
//    sprintf(str_p + strlen(str_p), "%s.idl.c", tmp_p);
//
//    NH_BYTE *buffer_p = 0;
//    long length;
//
//    FILE *f = fopen(str_p, "r");
//    if (f == NULL) {SELFMAKE_END(NH_FALSE)}
//
//    fseek (f, 0, SEEK_END);
//    length = ftell(f);
//    fseek (f, 0, SEEK_SET);
//
//    if (length > 0)
//    {
//        buffer_p = malloc(sizeof(NH_BYTE) * (length + 1));
//        if (buffer_p) {fread(buffer_p, 1, length, f);}
//        buffer_p[length] = '\0';
//
//        sprintf(str_p, "selfmake_%s_%s(\n", fragmentName_p, operationName_p);
//        if (strstr(buffer_p, str_p)) {SELFMAKE_END(NH_TRUE)}
//
//        free(buffer_p);
//    }
//
//    fclose(f);
//
//SELFMAKE_END(NH_FALSE)
//}

static SELFMAKE_RESULT selfmake_createIncludes(
    FILE *f)
{
SELFMAKE_BEGIN()

    fprintf(f, "// INCLUDE =========================================================================================\n\n");
    fprintf(f, "#include \"Builtin.h\"\n\n");

    for (int i = 0; i < fileCount; ++i) 
    {
        NH_BYTE fragmentName_p[1024] = {'\0'};
        selfmake_getFragmentName(files_pp[i], fragmentName_p);

        for (int j = 0; j < strlen(fragmentName_p); ++j) {
            if (fragmentName_p[j] == '_') {
                fragmentName_p[j] = '/';
            }
        }

        fprintf(f,"#include \"../Specifications/%s.idl.h\"\n", fragmentName_p);
    }

SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
}

static SELFMAKE_RESULT selfmake_createFragmentDataArrays(
    FILE *f, int mode)
{
SELFMAKE_BEGIN()

    if (mode == 0) {
        fprintf(f, "\n// FRAGMENT NAMES ==================================================================================\n\n");
        fprintf(f, "NH_BYTE *NH_WEBIDL_FRAGMENT_NAMES_PP[] = {\n");
    }
    else if (mode == 1) {
        fprintf(f, "\n// FRAGMENTS =======================================================================================\n\n");
        fprintf(f, "NH_UNSIGNED_BYTE *NH_WEBIDL_FRAGMENTS_PP[] = {\n");
    }
    else if (mode == 2) {
        fprintf(f, "\n// FRAGMENT LENGTHS =================================================================================\n\n");
        fprintf(f, "const unsigned int NH_WEBIDL_FRAGMENT_LENGTHS_P[] = {\n");
    }

    for (int i = 0; i < fileCount; ++i) 
    {
        NH_BYTE fragmentName_p[1024] = {'\0'}, *p;
        selfmake_getFragmentName(files_pp[i], fragmentName_p);

        if (mode == 0) {
            fprintf(f, "    \"%s\",\n", fragmentName_p);
        }
        else if (mode == 1) {
            fprintf(f, "    nh_webidl_%s_p,\n", fragmentName_p);
        }
        else if (mode == 2) {
            fprintf(f, "    nh_webidl_%s_p_len,\n", fragmentName_p);
        }
    }

    fprintf(f, "};\n");

    if (mode == 0) {
        fprintf(f, "\nsize_t NH_WEBIDL_FRAGMENT_NAMES_PP_COUNT = sizeof(NH_WEBIDL_FRAGMENT_NAMES_PP) / sizeof(NH_WEBIDL_FRAGMENT_NAMES_PP[0]);\n");
    }
    else if (mode == 1) {
        fprintf(f, "\nsize_t NH_WEBIDL_FRAGMENTS_PP_COUNT = sizeof(NH_WEBIDL_FRAGMENTS_PP) / sizeof(NH_WEBIDL_FRAGMENTS_PP[0]);\n");
    }

SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
}

//static SELFMAKE_RESULT selfmake_createFragmentFunctionArrays(
//    FILE *f, NH_BYTE *runtimePath_p, NH_BOOL asString)
//{
//SELFMAKE_BEGIN()
//
//    if (asString) {
//        fprintf(f, "\n// FRAGMENT FUNCTION NAMES =========================================================================\n\n");
//        fprintf(f, "const NH_BYTE *SELFMAKE_FRAGMENT_FUNCTION_NAMES_PP[] = {");
//    }
//    else {
//        fprintf(f, "\n// FRAGMENT FUNCTIONS ==============================================================================\n\n");
//        fprintf(f, "selfmake_Result (*SELFMAKE_FRAGMENT_FUNCTIONS_PP[]) (nh_ecmascript_Object *This_p, nh_List Arguments) = {");
//    }
//
//    for (int i = 0; i < fileCount; ++i) 
//    {
//        selfmake_Operation *Operation_p = &((selfmake_Operation*)Interface_p->Operations.bytes_p)[k];
//        if (selfmake_functionImplemented(runtimePath_p, fragmentName_p, Operation_p->name_p)) {
//            fprintf(f, asString ? "\n    \"%s_%s\"," : "\n    selfmake_%s_%s,", fragmentName_p, Operation_p->name_p);
//        }
//        else {
//            fprintf(f, asString ? "\n//    \"%s_%s\"," : "\n//    selfmake_%s_%s,", fragmentName_p, Operation_p->name_p);
//        }
//    }
//
//    fprintf(f, "\n};\n");
//
//    if (asString) {
//        fprintf(f, "\nsize_t SELFMAKE_FRAGMENT_FUNCTION_NAMES_PP_COUNT = sizeof(SELFMAKE_FRAGMENT_FUNCTION_NAMES_PP) / sizeof(SELFMAKE_FRAGMENT_FUNCTION_NAMES_PP[0]);\n");
//    }
//    else {
//        fprintf(f, "\nsize_t SELFMAKE_FRAGMENT_FUNCTIONS_PP_COUNT = sizeof(SELFMAKE_FRAGMENT_FUNCTIONS_PP) / sizeof(SELFMAKE_FRAGMENT_FUNCTIONS_PP[0]);\n");
//    }
//
//SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
//}

static SELFMAKE_RESULT selfmake_createIncludeFile(
    NH_BYTE *runtimePath_p)
{
SELFMAKE_BEGIN()

    NH_BYTE filepath_p[1024] = {'\0'};
    sprintf(filepath_p, "%s/Builtin.c", runtimePath_p);

    FILE *f = fopen(filepath_p, "w");
    if (f == NULL) {
        printf("Error opening file!\n");
        exit(1);
    }

    fprintf(f, "// LICENSE NOTICE ==================================================================================\n\n");
    fprintf(f, LICENSE_NOTICE);

    selfmake_createIncludes(f);
    selfmake_createFragmentDataArrays(f, 0);
    selfmake_createFragmentDataArrays(f, 1);
    selfmake_createFragmentDataArrays(f, 2);
//    selfmake_createFragmentFunctions(f, runtimePath_p, NH_TRUE);
//    selfmake_createFragmentFunctions(f, runtimePath_p, NH_FALSE);

    fclose(f);

SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
}

// HEADER ===========================================================================================

//static SELFMAKE_RESULT selfmake_generateOperationsFile(
//    NH_BYTE *fragmentName_p, NH_BYTE *outdir_p, NH_BYTE **operations_pp, int count)
//{
//SELFMAKE_BEGIN()
//
//    NH_BYTE *shortName_p = NULL;
//    for (int i = 0; i < strlen(fragmentName_p); ++i) {
//        if (fragmentName_p[i] == '_') {shortName_p = &fragmentName_p[i + 1]; break;}
//    }
//    SELFMAKE_CHECK_NULL(shortName_p)
//
//    NH_BYTE outfilepath_p[1024] = {'\0'};
//    sprintf(outfilepath_p, "%s/%s.h", outdir_p, shortName_p);
//
//    FILE *File_p = fopen(outfilepath_p, "w");
//    SELFMAKE_CHECK_NULL(File_p)
//
//    NH_BYTE fragmentNameUpper_p[1024] = {'\0'};
//    for (int i = 0; i < strlen(fragmentName_p); ++i) {
//        fragmentNameUpper_p[i] = toupper(fragmentName_p[i]);
//    }
//
//    fprintf(File_p,"#ifndef NH_%s_H\n#define NH_%s_H\n\n", fragmentNameUpper_p, fragmentNameUpper_p);
//
//    fprintf(File_p,"#ifndef DOXYGEN_SHOULD_SKIP_THIS\n\n");
//    fprintf(File_p, LICENSE_NOTICE);
//    fprintf(File_p,"#endif\n\n");
//
//    fprintf(File_p,"/** @addtogroup nhFunctions Functions\n *  @{\n */\n");
//
//    for (int i = 0; i < count; ++i) {
//        fprintf(
//            File_p, 
//            "\n    nh_Web_Result nh_%s_%s(\n        nh_Web_Object *This_p, nh_List Arguments\n    );\n", 
//            fragmentName_p, operations_pp[i]
//        );
//    }
//
//    fprintf(File_p,"\n/** @} */\n\n#endif");
//    fclose(File_p);
//
//    SELFMAKE_CHECK(selfmake_messagef("GENERATE %s", outfilepath_p))
//
//SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
//}

static SELFMAKE_RESULT selfmake_generateHexDumpFile(
    NH_BYTE *filePath_p, NH_BYTE *fragmentName_p)
{
SELFMAKE_BEGIN()

    NH_BYTE outfilepath_p[1024] = {'\0'};
    sprintf(outfilepath_p, "%s.h", filePath_p);

    FILE *File_p = fopen(outfilepath_p, "w");
    SELFMAKE_CHECK_NULL(File_p)

    NH_BYTE name_p[1024] = {'\0'};
    sprintf(name_p, "nh_webidl_%s", fragmentName_p);

    NH_BYTE command_p[1024] = {'\0'};
    sprintf(command_p, "./external/xxd/xxd -i %s %s.h nh_webidl_%s_p", filePath_p, filePath_p, fragmentName_p);

    int status = system(command_p);
    if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SELFMAKE_DIAGNOSTIC_END(SELFMAKE_ERROR_XXD_EXECUTION_FAILED)}

    fclose(File_p);

    SELFMAKE_CHECK(selfmake_messagef("GENERATE %s", outfilepath_p))

SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
}

// GET OPERATIONS ==================================================================================

SELFMAKE_RESULT selfmake_getFragmentOperations(
    NH_BYTE *filePath_p, NH_BYTE **operations_pp, int *count_p)
{
SELFMAKE_BEGIN()

    long size = 0;
    NH_BYTE *bytes_p = selfmake_getFileData(filePath_p, &size);
    SELFMAKE_CHECK_NULL(bytes_p)

    int operation = 0;

    for (int i = 0, depth = 0; i < size; ++i) 
    {
             if (bytes_p[i] == '{') {depth++;}
        else if (bytes_p[i] == '}') {depth--;}
        else if (depth > 0) 
        {
            if (bytes_p[i] == '(') 
            {
                bytes_p[i] = '\0';
                int begin = i;
                while (bytes_p[begin] == ' ' && begin > 0) {--begin;}
                while (bytes_p[begin] != ' ' && begin > 0) {--begin;}
                NH_BYTE *operation_p = malloc(sizeof(NH_BYTE) * ((i - begin) + 1));
                SELFMAKE_CHECK_NULL(operation_p)
                strcpy(operation_p, bytes_p + begin + 1);
                operations_pp[operation++] = operation_p;
                bytes_p[i] = '(';
                while (bytes_p[i] != ';' && i < size) {++i;}
            } 
        }
    }

    *count_p = operation;
    free(bytes_p);

SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
}

// MAIN ============================================================================================

static SELFMAKE_RESULT selfmake_processWebFragment(
    NH_BYTE *filePath_p)
{
SELFMAKE_BEGIN()

    int count = 0;
    SELFMAKE_CHECK(selfmake_getFragmentOperations(filePath_p, &totalOperations_pp[totalOperationCount], &count))
    totalOperationCount += count;

    NH_BYTE fragmentName_p[1024] = {'\0'};
    selfmake_getFragmentName(filePath_p, fragmentName_p);

    SELFMAKE_CHECK(selfmake_generateHexDumpFile(filePath_p, fragmentName_p))
    SELFMAKE_CHECK(selfmake_createIncludeFile("src/lib/nhwebidl/Runtime"))

SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
}

SELFMAKE_RESULT selfmake_processWebIDL()
{
SELFMAKE_BEGIN()

    for (int i = 0; i < fileCount; ++i) {
        SELFMAKE_CHECK(selfmake_processWebFragment(files_pp[i]))
    }

SELFMAKE_DIAGNOSTIC_END(SELFMAKE_SUCCESS)
} 

